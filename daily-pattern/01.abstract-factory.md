# Abstract Factory
추상 팩토리는 객체 생성 과정을 추상화합니다.<br>
추상 팩토리는 같은 군(family)에 속하는 콘크리트 클래스들을 생성하는 인터페이스를 제공합니다.<br>
<br>

### 동기
여러 룩앤필을 지원하는 UI가 있다고 가정합시다. 다른 룩앤필은 위젯들(스크롤바, 창, 버튼)을 다른 생김새로 보여지게 합니다. 클래스 작성자는 **룩앤필이 실시간으로 변경될 수 있도록 위젯들을 생설하는 코드를 하드코딩 해서는 안됩니다.** 우리는 이 문제를 추상 위젯 팩토리 클래스로 해결할 수 있습니다. 위젯 팩토리 클래스가 룩앤필에 해당하는 위젯들을 생성하는 메소드를 제공하며, 이 메소드들은 생성된 위젯들의 인터페이스를 반환하므로, 클래스 사용자는 위젯들의 구현 클래스에 대해서는 모릅니다.

### 의문점
룩앤필이 실시간으로 변경될 수 있도록 위젯들을 생성하는 코드를 하드코딩 해서는 안 된다, 그래서 추상 위젯 팩토리 클래스를 사용해야 한다고 했습니다. 그런데 이 문제는 어떤 룩앤필의 위젯들을 생성할지 switch문을 통해 결정하게 함으로써 간단히 해결할 수 있지 않을까요?

### 샘플 코드
```java
// switch문의 예
interface RobotHead {...}
interface RobotBody {...}
interface RobotArms {...}
interface RobotLegs {...}

class TaekwonVHead extends RobotHead {...}
class TaekwonVBody extends RobotBody {...}
class TaekwonVArms extends RobotArms {...}
class TaekwonVLegs extends RobotLegs {...}

class MazingaHead extends RobotHead {...}
class MazingaBody extends RobotBody {...}
class MazingaArms extends RobotArms {...}
class MazingaLegs extends RobotLegs {...}

public static void main(String[] args) {
	String robotName = "TaekwonV";
	RobotHead robotHead = null;
	RobotBody robotBody = null;
	RobotArms robotArms = null;
	RobotLegs robotLegs = null;
	
	switch(rootName) {
		case "TaekwonV":
			robotHead = new TaekwonVHead();
			robotBody = new TaekwonVBody();
			robotArms = new TaekwonVArms();
			robotLegs = new TaekwonVLegs();
			break;
		case "Mazinga":
			robotHead = new MazingaHead();
			robotBody = new MazingaBody();
			robotArms = new MazingaArms();
			robotLegs = new MazingaLegs();
			break;
	}
}

```

```java
// 추상 팩토리 패턴의 예

interface RobotHead {...}
interface RobotBody {...}
interface RobotArms {...}
interface RobotLegs {...}

class TaekwonVHead extends RobotHead {...}
class TaekwonVBody extends RobotBody {...}
class TaekwonVArms extends RobotArms {...}
class TaekwonVLegs extends RobotLegs {...}

class MazingaHead extends RobotHead {...}
class MazingaBody extends RobotBody {...}
class MazingaArms extends RobotArms {...}
class MazingaLegs extends RobotLegs {...}

interface RobotPartsFactory {
	RobotHead createRotoHead();
	RobotBody createRotoBody();
	RobotArms createRotoArms();
	RobotLegs createRotoLegs();
}

class TeakwonVPartsFactory extends RobotPartsFactory {
	RobotHead createRotoHead() { return new TaekwonVHead(); }
	RobotBody createRotoBody() { return new TaekwonVBody(); }
	RobotArms createRotoArms() { return new TaekwonVArms(); }
	RobotLegs createRotoLegs() { return new TaekwonVLegs(); }
}

class MazingaPartsFactory extends RobotPartsFactory {
	RobotHead createRotoHead() { return new MazingaHead(); }
	RobotBody createRotoBody() { return new MazingaBody(); }
	RobotArms createRotoArms() { return new MazingaArms(); }
	RobotLegs createRotoLegs() { return new MazingaLegs(); }
}

public static void main(String[] args) {
	
}
```
<br>

### 개념 리마인드
추상 팩토리는 클래스 사용자로부터 요청받은 제품군의 제품들을 생성하는 메소드들을 제공합니다.<br>
구현 팩토리는 자신이 맡고 있는 제품군의 제품들을 생성합니다.
추상 제품은, 추상 팩토리가 생성한 제품들을 클래스 사용자가 받을 때 인터페이스로 받는데, 이 인터페이스가 추상 제품입니다.
구현 제품은 구현 팩토리에 의해 생성되는 제품입니다.

### 이럴 때 사용합니다.
- 시스템을 구성하는 제품들이 어떻게 생성되고 구성되는지에 대해서 독립적으로 만들어야 할 때
- 여러 제품군(family)들 중 하나의 제품군을 뽑아내야 할 때
- 같은 군(family)에 소속된 제품들이 함께 사용되도록 설계되야 할 때
- 제품들을 라이브러리로 제공하고자 하는 상황에서 제품들의 구현은 숨기고 제품들의 인터페이스만 보여주고자 할 때

### 
